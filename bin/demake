#!/usr/bin/env ruby

#
# demake - Executeable script which uses Ruby to generate decorated make files
#          for multiple related applications.

require 'pipetext'

debug = true
quiet = false
compiler = "gcc"
#compiler = "clang"
#compiler = "arm-none-eabi-gcc"
#compiler = "arm-linux-gnu-gcc"
binary_directory = "bin"
source_directory = "src"
object_directory = "obj"
@raw_binary_files = String.new

flags = "-ansi -pedantic -D_DEFAULT_SOURCE"
#flags = "-ansi -pedantic -static -static-libgcc"

libraries = "-lc"

@pipe = Class.new.extend(PipeText)

begin
  code = File.open('demake/settings.rb').read
  eval code
rescue Errno::ENOENT
rescue
  STDERR.puts(@pipe.pipetext("\n|YWARNING|n: #{$!}\n\n"))
end

begin
  # The expected format is the application followed by a list of its dependencies
  # all on the same line separated by space, : or tab.
  application_and_dependencies = File.open('demake/applications').read.split(/\n/)
  @applications = Hash.new
  application_and_dependencies.each do |app|
    if(app =~ /([^ :\t]*)[ :\t]*(.*)/)
      @applications[$1] = Hash.new
      @applications[$1]['dependencies'] = $2.split(/[ :\t]/)
    else
      @applications[app] = Hash.new
    end
  end
rescue Errno::ENOENT
  STDERR.puts(@pipe.pipetext("\n|RError|n: |Yapplications file|n |Rdoes not exist|n\n\n" +
             "You must create a file named |Yapplications|n which contains a list of\n" +
             "executeable application names and any dependencies to be compiled.\n\n"))
  exit!
rescue
  puts $!.inspect
end

if(@applications == {})
  STDERR.puts(@pipe.pipetext("\n|RError|n: |Yapplications file|n |Rcannot be empty|n\n\n" +
             "You must create a file named |Yapplications|n which contains a list of\n" +
             "executeable application names and any dependencies to be compiled.\n\n"))
  exit!
end

@output = <<-END_OF_STRING
#
# Makefile automatically generated by demake
#
END_OF_STRING

if(debug)
  @output << "DEBUG = true\n"
else
  @output << "DEBUG = false\n"
end
if(quiet)
  @output << "MAKE += -s\n"
end

compiler_settings = <<-END_OF_STRING
CC = #{compiler}
OS := $(shell uname)
PROCESSOR := $(shell uname -p)
MACHINE := $(shell uname -m)
END_OF_STRING

@output << compiler_settings

compiler_flags = <<-END_OF_STRING
FLAGS = #{flags}
ifeq '$(OS)' 'Linux'
  ifeq '$(CC)' 'gcc'
    FLAGS += -static -static-libgcc
  else
    FLAGS += -static
  endif
endif
ifeq '$(OS)' 'Darwin'
  FLAGS += -bundle
endif
ifeq '$(MACHINE)' 'aarch64'
  FLAGS += -march=native
endif
ifeq '$(DEBUG)' 'true'
  FLAGS += -g -Wall -W -Wconversion -Wshadow -Wcast-qual -Wwrite-strings
else
  FLAGS += -O2
endif
CFLAGS = $(FLAGS)
END_OF_STRING

if(defined?($flags_override))
STDERR.puts("Overriding compiler flags")
  compiler_flags = "FLAGS = #{flags}\nCFLAGS = $(FLAGS)\n"
end
@output << compiler_flags

compiler_directories = <<-END_OF_STRING
LIBS = #{libraries}
BINARY = #{binary_directory}
SOURCE = #{source_directory}
OBJECT = #{object_directory}
END_OF_STRING

@output << compiler_directories

#SOURCES = $(wildcard $(SOURCE)/*.c $(SOURCE)/*.h)
#OBJECTS = $(patsubst $(SOURCE)/%.c, $(OBJECT)/%.o, $(SOURCES))

counter = 0
@applications.each do |app|
  counter += 1
  @output << "#\n# #{app[0]} - File List (FL#{counter})\n#\n"
  # test to see if there is a app.c and we need app.o
  begin
    File.open(source_directory + '/' + "#{app[0]}.c")
    @output << "FL#{counter} = #{app[0]}.o"
  rescue Errno::ENOENT
    @output << "FL#{counter} ="
  end
  app[1]['dependencies'].each do |dep|
    if(File.directory?(source_directory + '/' + dep) == true)
      Dir.entries(source_directory + '/' + dep).each do |e|
        if(e != '.' && e != '..' && e =~ /(.*)\.cp?p?$/)
          Dir.chdir(source_directory + '/' + dep) do
            if(File.directory?(e) == false)
              @output << " " + dep + '/' + $1 + '.o'
            end
          end
        end
      end
    else
      @output << " " + dep.sub(/\.cp?p?$/, '.o')
    end
  end
  @output << "\n"
  @output << "#\n# #{app[0]} - Object List (OL#{counter})\n#\n"
  @output << "OL#{counter} = $(patsubst %.o, $(OBJECT)/%.o, $(FL#{counter}))\n"
end

menu_target = <<-END_OF_STRING
menu :
\t@clear
\t@echo "|-[|20-]|o"
\t@echo "|]28|-! Make targets:|;!|o"
\t@echo "|]28|-!|;!|o"
\t@echo "|]27|-! |g|[wrench]|n |Cbuild|n|;!|o"
\t@echo "|]27|-! |B|[droplet]|n |Cclean|n|;!|o"
\t@echo "|]27|-! |s|[nut and bolt]|n |Cinstall|n|;!|o"
\t@echo "|]27|-! |m|[counterclockwise arrows button]|n |Ctest|n|;!|o"
\t@echo "|-{|20-}|o"
END_OF_STRING
@output << "\n"
@output << @pipe.pipetext(menu_target)

default_target = <<-END_OF_STRING
default :
\t@clear
END_OF_STRING

@applications.each do |app|
  execute_target = <<-END_OF_STRING
\t@echo "|-[|50-]|o"
\t@echo "|]57|-! |g|[wrench] |nBuilding executable: |g#{app[0]}|n|;!|o"
\t@echo "|-{|50-}|o"
\t@$(MAKE) #{app[0]}
END_OF_STRING
  default_target << @pipe.pipetext(execute_target)
end

@output << "\n"
@output << default_target

build_target = <<-END_OF_STRING
build :
\t@clear
END_OF_STRING

@applications.each do |app|
  execute_target = <<-END_OF_STRING
\t@echo "|-[|50-]|o"
\t@echo "|]57|-! |g|[wrench] |nBuilding executable: |g#{app[0]}|n|;!|o"
\t@echo "|-{|50-}|o"
\t@$(MAKE) #{app[0]}
END_OF_STRING
  build_target << @pipe.pipetext(execute_target)
end

@output << "\n"
@output << build_target

def add_dependencies(filename, path)
  begin
    dependencies = String.new
    File.readlines(filename).each do |line|
      if(line =~ /^#include \"(.*)\"/)
        dependencies << "\t\\\n\t$(SOURCE)#{path}#{$1}"
      end
    end
    if(dependencies != "")
      dependency_targets = <<-END_OF_STRING
# Dependencies
$(OBJECT)#{path}#{filename.sub(/\.cp?p?$/, '.o')} : $(SOURCE)#{path}#{filename}#{dependencies}
\t@echo "|=!|O |R|[fire]|n Compiling... |c$(OBJECT)#{path}#{filename.sub(/\.cp?p?$/, '.o')}|n"
ifeq '$(OS)' 'Linux'
\t@mkdir -p $(OBJECT)#{path}
else
\t@if not exist $(OBJECT)#{path} @mkdir $(OBJECT)#{path}
endif
\t$(CC) $(CFLAGS) -c $(SOURCE)#{path}#{filename} -o $(OBJECT)#{path}#{filename.gsub(/\.cp?p?$/, '.o')}
END_OF_STRING
      @output << "\n" + @pipe.pipetext(dependency_targets)
    end
  rescue
    STDERR.puts(@pipe.pipetext("|YWARNING|n: #{$!}"))
    STDERR.puts(@pipe.pipetext("|YWARNING|n: including #{path}#{$1}#{filename} as raw binary"))
    @raw_binary_files << " $(SOURCE)#{path}#{$1}#{filename}"
  end
end

def add_all_dependencies(directory, path)
  Dir.entries(directory).each do |e|
    if(e != '.' && e != '..')
      Dir.chdir(directory) do
        if(File.directory?(e) == true)
          add_all_dependencies(e, path + e + '/')
        end
      end
    end
  end
  Dir.entries(directory).each do |e|
    if(e != '.' && e != '..')
      Dir.chdir(directory) do
        if(File.directory?(e) == false)
          add_dependencies(e, path)
        end
      end
    end
  end
end

add_all_dependencies(source_directory, '/')

counter = 0
@applications.each do |app|
  counter += 1
  execute_target = <<-END_OF_STRING
#{app[0]} : $(OL#{counter})
\t@echo "|-[|50-]|o"
\t@echo "|]57|-! |B|[link]|n Linking Files... |g#{app[0]}|n|;!|o"
\t@echo "|-{|50-}|o"
ifeq '$(OS)' 'Linux'
\t@mkdir -p $(BINARY)
else
\t@if not exist $(BINARY) @mkdir $(BINARY)
endif
\t$(CC) $(LIBS) -o $(BINARY)/#{app[0]} $(OL#{counter})#{@raw_binary_files}
END_OF_STRING
  @output << "\n"
  @output << @pipe.pipetext(execute_target)
end

dependency_targets = <<-END_OF_STRING
# General Auto-Dependencies
$(OBJECT)/%.o : $(SOURCE)/%.c
\t@echo "|=!|o |R|[fire]|n Compiling... |c$(@)|n"
ifeq '$(OS)' 'Linux'
\t@mkdir -p $(BINARY)
\t@mkdir -p $(OBJECT)
else
\t@if not exist $(BINARY) @mkdir $(BINARY)
\t@if not exist $(OBJECT) @mkdir $(OBJECT)
endif
\t$(CC) $(CFLAGS) -c $< -o $@
END_OF_STRING
@output << "\n" + @pipe.pipetext(dependency_targets)

clean_target = <<-END_OF_STRING
clean :
\t@echo "|B|[droplet]|n Removed |Yeverything|n from |R$(OBJECT)|n and |R$(BINARY)|n directories"
ifeq '$(OS)' 'Linux'
\t@rm -rf $(OBJECT) $(BINARY)
else
\t@if exist $(OBJECT)\*.* erase /Q $(OBJECT)\*.*
\t@if exist $(OBJECT) rmdir $(OBJECT)
\t@if exist $(BINARY)\*.* erase /Q $(BINARY)\*.*
\t@if exist $(BINARY) rmdir $(BINARY)
endif
END_OF_STRING
@output << @pipe.pipetext(clean_target + "\n")

test_target = <<-END_OF_STRING
test :
\t@echo "|m|[counterclockwise arrows button]|n Starting tests..."
END_OF_STRING
begin
  code = File.open('demake/test-target.rb').read
  eval code
rescue Errno::ENOENT
  test_targets = <<-END_OF_STRING
\t@echo "|R|[cross mark]|n  |rNo tests have been executed|n"
END_OF_STRING
  test_target << test_targets
rescue
  STDERR.puts(@pipe.pipetext("\n|YWARNING|n: #{$!}\n\n"))
end
@output << @pipe.pipetext(test_target)

install_target = <<-END_OF_STRING
install :
\t@echo "|s|[nut and bolt]|n Starting install..."
END_OF_STRING
begin
  code = File.open('demake/install-target.rb').read
  eval code
rescue Errno::ENOENT
  install_targets = <<-END_OF_STRING
\t@echo "|R|[cross mark]|n  |rNo install scripts have been executed|n"
END_OF_STRING
  install_target << install_targets
rescue
  STDERR.puts(@pipe.pipetext("\n|YWARNING|n: #{$!}\n\n"))
end
@output << @pipe.pipetext(install_target)

puts @output
